{"version":3,"sources":["index.js","lazy.js","util.js","listener.js","lazy-component.js","lazy-container.js","lazy-image.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AFOA,AIZA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AGRA,ACHA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;AIXA,ALeA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\nexports.Lazyload = void 0;\n\nvar _lazy = _interopRequireDefault(require(\"./lazy\"));\n\nvar _lazyComponent = _interopRequireDefault(require(\"./lazy-component\"));\n\nvar _lazyContainer = _interopRequireDefault(require(\"./lazy-container\"));\n\nvar _lazyImage = _interopRequireDefault(require(\"./lazy-image\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Lazyload = {\n  /*\n   * install function\n   * @param  {App} app\n   * @param  {object} options lazyload options\n   */\n  install(app, options = {}) {\n    var LazyClass = (0, _lazy.default)();\n    var lazy = new LazyClass(options);\n    var lazyContainer = new _lazyContainer.default({\n      lazy\n    });\n    app.config.globalProperties.$Lazyload = lazy;\n\n    if (options.lazyComponent) {\n      app.component('LazyComponent', (0, _lazyComponent.default)(lazy));\n    }\n\n    if (options.lazyImage) {\n      app.component('LazyImage', (0, _lazyImage.default)(lazy));\n    }\n\n    app.directive('lazy', {\n      beforeMount: lazy.add.bind(lazy),\n      updated: lazy.update.bind(lazy),\n      unmounted: lazy.remove.bind(lazy)\n    });\n    app.directive('lazy-container', {\n      beforeMount: lazyContainer.bind.bind(lazyContainer),\n      updated: lazyContainer.update.bind(lazyContainer),\n      unmounted: lazyContainer.unbind.bind(lazyContainer)\n    });\n  }\n\n};\nexports.Lazyload = Lazyload;","\n\nexports.__esModule = true;\nexports.default = _default;\n\nvar _vue = require(\"vue\");\n\nvar _util = require(\"./util\");\n\nvar _listener = _interopRequireDefault(require(\"./listener\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DEFAULT_URL = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\nvar DEFAULT_EVENTS = ['scroll', 'wheel', 'mousewheel', 'resize', 'animationend', 'transitionend', 'touchmove'];\nvar DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: '0px',\n  threshold: 0\n};\n\nfunction _default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = _util.modeType.event;\n      this.ListenerQueue = [];\n      this.TargetIndex = 0;\n      this.TargetQueue = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || (0, _util.getDPR)(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        hasbind: false,\n        supportWebp: (0, _util.supportWebp)(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n\n      this._initEvent();\n\n      this._imageCache = new _util.ImageCache({\n        max: 200\n      });\n      this.lazyLoadHandler = (0, _util.throttle)(this._lazyLoadHandler.bind(this), this.options.throttleWait);\n      this.setMode(this.options.observer ? _util.modeType.observer : _util.modeType.event);\n    }\n    /**\n     * update config\n     * @param  {Object} config params\n     * @return\n     */\n\n\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * output listener's load performance\n     * @return {Array}\n     */\n\n\n    performance() {\n      return this.ListenerQueue.map(item => item.performance());\n    }\n    /*\n     * add lazy component to queue\n     * @param  {Vue} vm lazy component instance\n     * @return\n     */\n\n\n    addLazyBox(vm) {\n      this.ListenerQueue.push(vm);\n\n      if (_util.inBrowser) {\n        this._addListenerTarget(window);\n\n        this._observer && this._observer.observe(vm.el);\n\n        if (vm.$el && vm.$el.parentNode) {\n          this._addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    /*\n     * add image listener to queue\n     * @param  {DOM} el\n     * @param  {object} binding vue directive binding\n     * @param  {vnode} vnode vue directive vnode\n     * @return\n     */\n\n\n    add(el, binding, vnode) {\n      if (this.ListenerQueue.some(item => item.el === el)) {\n        this.update(el, binding);\n        return (0, _vue.nextTick)(this.lazyLoadHandler);\n      }\n\n      var value = this._valueFormatter(binding.value);\n\n      var {\n        src\n      } = value;\n      (0, _vue.nextTick)(() => {\n        src = (0, _util.getBestSelectionFromSrcset)(el, this.options.scale) || src;\n        this._observer && this._observer.observe(el);\n        var container = Object.keys(binding.modifiers)[0];\n        var $parent;\n\n        if (container) {\n          $parent = vnode.context.$refs[container]; // if there is container passed in, try ref first, then fallback to getElementById to support the original usage\n\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n\n        if (!$parent) {\n          $parent = (0, _util.scrollParent)(el);\n        }\n\n        var newListener = new _listener.default({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this._elRenderer.bind(this),\n          options: this.options,\n          imageCache: this._imageCache\n        });\n        this.ListenerQueue.push(newListener);\n\n        if (_util.inBrowser) {\n          this._addListenerTarget(window);\n\n          this._addListenerTarget($parent);\n        }\n\n        this.lazyLoadHandler();\n        (0, _vue.nextTick)(() => this.lazyLoadHandler());\n      });\n    }\n    /**\n     * update image src\n     * @param  {DOM} el\n     * @param  {object} vue directive binding\n     * @return\n     */\n\n\n    update(el, binding, vnode) {\n      var value = this._valueFormatter(binding.value);\n\n      var {\n        src\n      } = value;\n      src = (0, _util.getBestSelectionFromSrcset)(el, this.options.scale) || src;\n      var exist = (0, _util.find)(this.ListenerQueue, item => item.el === el);\n\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n\n      if (this._observer) {\n        this._observer.unobserve(el);\n\n        this._observer.observe(el);\n      }\n\n      this.lazyLoadHandler();\n      (0, _vue.nextTick)(() => this.lazyLoadHandler());\n    }\n    /**\n     * remove listener form list\n     * @param  {DOM} el\n     * @return\n     */\n\n\n    remove(el) {\n      if (!el) return;\n      this._observer && this._observer.unobserve(el);\n      var existItem = (0, _util.find)(this.ListenerQueue, item => item.el === el);\n\n      if (existItem) {\n        this._removeListenerTarget(existItem.$parent);\n\n        this._removeListenerTarget(window);\n\n        (0, _util.remove)(this.ListenerQueue, existItem);\n        existItem.$destroy();\n      }\n    }\n    /*\n     * remove lazy components form list\n     * @param  {Vue} vm Vue instance\n     * @return\n     */\n\n\n    removeComponent(vm) {\n      if (!vm) return;\n      (0, _util.remove)(this.ListenerQueue, vm);\n      this._observer && this._observer.unobserve(vm.el);\n\n      if (vm.$parent && vm.$el.parentNode) {\n        this._removeListenerTarget(vm.$el.parentNode);\n      }\n\n      this._removeListenerTarget(window);\n    }\n\n    setMode(mode) {\n      if (!_util.hasIntersectionObserver && mode === _util.modeType.observer) {\n        mode = _util.modeType.event;\n      }\n\n      this.mode = mode; // event or observer\n\n      if (mode === _util.modeType.event) {\n        if (this._observer) {\n          this.ListenerQueue.forEach(listener => {\n            this._observer.unobserve(listener.el);\n          });\n          this._observer = null;\n        }\n\n        this.TargetQueue.forEach(target => {\n          this._initListen(target.el, true);\n        });\n      } else {\n        this.TargetQueue.forEach(target => {\n          this._initListen(target.el, false);\n        });\n\n        this._initIntersectionObserver();\n      }\n    }\n    /*\n     *** Private functions ***\n     */\n\n    /*\n     * add listener target\n     * @param  {DOM} el listener target\n     * @return\n     */\n\n\n    _addListenerTarget(el) {\n      if (!el) return;\n      var target = (0, _util.find)(this.TargetQueue, target => target.el === el);\n\n      if (!target) {\n        target = {\n          el,\n          id: ++this.TargetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === _util.modeType.event && this._initListen(target.el, true);\n        this.TargetQueue.push(target);\n      } else {\n        target.childrenCount++;\n      }\n\n      return this.TargetIndex;\n    }\n    /*\n     * remove listener target or reduce target childrenCount\n     * @param  {DOM} el or window\n     * @return\n     */\n\n\n    _removeListenerTarget(el) {\n      this.TargetQueue.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n\n          if (!target.childrenCount) {\n            this._initListen(target.el, false);\n\n            this.TargetQueue.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    /*\n     * add or remove eventlistener\n     * @param  {DOM} el DOM or Window\n     * @param  {boolean} start flag\n     * @return\n     */\n\n\n    _initListen(el, start) {\n      this.options.ListenEvents.forEach(evt => _util._[start ? 'on' : 'off'](el, evt, this.lazyLoadHandler));\n    }\n\n    _initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event]) this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n\n      this.$once = (event, func) => {\n        var on = (...args) => {\n          this.$off(event, on);\n          func.apply(this, args);\n        };\n\n        this.$on(event, on);\n      };\n\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event]) return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n\n        (0, _util.remove)(this.Event.listeners[event], func);\n      };\n\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event]) return;\n        this.Event.listeners[event].forEach(func => func(context, inCache));\n      };\n    }\n    /**\n     * find nodes which in viewport and trigger load\n     * @return\n     */\n\n\n    _lazyLoadHandler() {\n      var freeList = [];\n      this.ListenerQueue.forEach(listener => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n\n        var catIn = listener.checkInView();\n        if (!catIn) return;\n        listener.load();\n      });\n      freeList.forEach(item => {\n        (0, _util.remove)(this.ListenerQueue, item);\n        item.$destroy();\n      });\n    }\n    /**\n     * init IntersectionObserver\n     * set mode to observer\n     * @return\n     */\n\n\n    _initIntersectionObserver() {\n      if (!_util.hasIntersectionObserver) {\n        return;\n      }\n\n      this._observer = new IntersectionObserver(this._observerHandler.bind(this), this.options.observerOptions);\n\n      if (this.ListenerQueue.length) {\n        this.ListenerQueue.forEach(listener => {\n          this._observer.observe(listener.el);\n        });\n      }\n    }\n    /**\n     * init IntersectionObserver\n     * @return\n     */\n\n\n    _observerHandler(entries) {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          this.ListenerQueue.forEach(listener => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded) return this._observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    /**\n     * set element attribute with image'url and state\n     * @param  {object} lazyload listener object\n     * @param  {string} state will be rendered\n     * @param  {bool} inCache  is rendered from cache\n     * @return\n     */\n\n\n    _elRenderer(listener, state, cache) {\n      if (!listener.el) return;\n      var {\n        el,\n        bindType\n      } = listener;\n      var src;\n\n      switch (state) {\n        case 'loading':\n          src = listener.loading;\n          break;\n\n        case 'error':\n          src = listener.error;\n          break;\n\n        default:\n          ({\n            src\n          } = listener);\n          break;\n      }\n\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute('src') !== src) {\n        el.setAttribute('src', src);\n      }\n\n      el.setAttribute('lazy', state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n\n      if (this.options.dispatchEvent) {\n        var event = new _util.CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    /**\n     * generate loading loaded error image url\n     * @param {string} image's src\n     * @return {object} image's loading, loaded, error url\n     */\n\n\n    _valueFormatter(value) {\n      var src = value;\n      var {\n        loading,\n        error\n      } = this.options; // value is object\n\n      if ((0, _util.isObject)(value)) {\n        if (!value.src && !this.options.silent) console.error('Vue Lazyload warning: miss src with ' + value);\n        ({\n          src\n        } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n\n  };\n}","\n\nexports.__esModule = true;\nexports.remove = remove;\nexports.find = find;\nexports.noop = noop;\nexports.isObject = isObject;\nexports.throttle = throttle;\nexports.supportWebp = supportWebp;\nexports.getBestSelectionFromSrcset = getBestSelectionFromSrcset;\nexports.loadImageAsync = exports.scrollParent = exports.getDPR = exports._ = exports.CustomEvent = exports.inBrowser = exports.ImageCache = exports.modeType = exports.hasIntersectionObserver = void 0;\nvar inBrowser = typeof window !== 'undefined' && window !== null;\nexports.inBrowser = inBrowser;\n\nfunction checkIntersectionObserver() {\n  if (inBrowser && 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n    // Minimal polyfill for Edge 15's lack of `isIntersecting`\n    // See: https://github.com/w3c/IntersectionObserver/issues/211\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n      Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {\n        get() {\n          return this.intersectionRatio > 0;\n        }\n\n      });\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar hasIntersectionObserver = checkIntersectionObserver();\nexports.hasIntersectionObserver = hasIntersectionObserver;\nvar modeType = {\n  event: 'event',\n  observer: 'observer'\n}; // CustomEvent polyfill\n\nexports.modeType = modeType;\n\nvar CustomEvent = function () {\n  if (!inBrowser) return;\n  if (typeof window.CustomEvent === 'function') return window.CustomEvent;\n\n  function CustomEvent(event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n\n  CustomEvent.prototype = window.Event.prototype;\n  return CustomEvent;\n}();\n\nexports.CustomEvent = CustomEvent;\n\nfunction remove(arr, item) {\n  if (!arr.length) return;\n  var index = arr.indexOf(item);\n  if (index > -1) return arr.splice(index, 1);\n}\n\nfunction getBestSelectionFromSrcset(el, scale) {\n  if (el.tagName !== 'IMG' || !el.getAttribute('data-srcset')) return;\n  var options = el.getAttribute('data-srcset');\n  var container = el.parentNode;\n  var containerWidth = container.offsetWidth * scale;\n  var spaceIndex;\n  var tmpSrc;\n  var tmpWidth;\n  options = options.trim().split(',');\n  var result = options.map(item => {\n    item = item.trim();\n    spaceIndex = item.lastIndexOf(' ');\n\n    if (spaceIndex === -1) {\n      tmpSrc = item;\n      tmpWidth = 999998;\n    } else {\n      tmpSrc = item.substr(0, spaceIndex);\n      tmpWidth = parseInt(item.substr(spaceIndex + 1, item.length - spaceIndex - 2), 10);\n    }\n\n    return [tmpWidth, tmpSrc];\n  });\n  result.sort(function (a, b) {\n    if (a[0] < b[0]) {\n      return 1;\n    }\n\n    if (a[0] > b[0]) {\n      return -1;\n    }\n\n    if (a[0] === b[0]) {\n      if (b[1].indexOf('.webp', b[1].length - 5) !== -1) {\n        return 1;\n      }\n\n      if (a[1].indexOf('.webp', a[1].length - 5) !== -1) {\n        return -1;\n      }\n    }\n\n    return 0;\n  });\n  var bestSelectedSrc = '';\n  var tmpOption;\n\n  for (var i = 0; i < result.length; i++) {\n    tmpOption = result[i];\n    bestSelectedSrc = tmpOption[1];\n    var next = result[i + 1];\n\n    if (next && next[0] < containerWidth) {\n      bestSelectedSrc = tmpOption[1];\n      break;\n    } else if (!next) {\n      bestSelectedSrc = tmpOption[1];\n      break;\n    }\n  }\n\n  return bestSelectedSrc;\n}\n\nfunction find(arr, fn) {\n  var item;\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (fn(arr[i])) {\n      item = arr[i];\n      break;\n    }\n  }\n\n  return item;\n}\n\nvar getDPR = (scale = 1) => inBrowser ? window.devicePixelRatio || scale : scale;\n\nexports.getDPR = getDPR;\n\nfunction supportWebp() {\n  if (!inBrowser) return false;\n  var support = true;\n\n  try {\n    var elem = document.createElement('canvas');\n\n    if (elem.getContext && elem.getContext('2d')) {\n      support = elem.toDataURL('image/webp').indexOf('data:image/webp') === 0;\n    }\n  } catch (err) {\n    support = false;\n  }\n\n  return support;\n}\n\nfunction throttle(action, delay) {\n  var timeout = null;\n  var lastRun = 0;\n  return function (...args) {\n    if (timeout) {\n      return;\n    }\n\n    var elapsed = Date.now() - lastRun;\n\n    var runCallback = () => {\n      lastRun = Date.now();\n      timeout = false;\n      action.apply(this, args);\n    };\n\n    if (elapsed >= delay) {\n      runCallback();\n    } else {\n      timeout = setTimeout(runCallback, delay);\n    }\n  };\n}\n\nfunction testSupportsPassive() {\n  if (!inBrowser) return;\n  var support = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get() {\n        support = true;\n      }\n\n    });\n    window.addEventListener('test', null, opts);\n  } catch (e) {//\n  }\n\n  return support;\n}\n\nvar supportsPassive = testSupportsPassive();\nvar _ = {\n  on(el, type, func, capture = false) {\n    if (supportsPassive) {\n      el.addEventListener(type, func, {\n        capture,\n        passive: true\n      });\n    } else {\n      el.addEventListener(type, func, capture);\n    }\n  },\n\n  off(el, type, func, capture = false) {\n    el.removeEventListener(type, func, capture);\n  }\n\n};\nexports._ = _;\n\nvar loadImageAsync = (item, resolve, reject) => {\n  var image = new Image();\n\n  if (!item || !item.src) {\n    var err = new Error('image src is required');\n    return reject(err);\n  }\n\n  image.src = item.src;\n\n  if (item.cors) {\n    image.crossOrigin = item.cors;\n  }\n\n  image.onload = function () {\n    resolve({\n      naturalHeight: image.naturalHeight,\n      naturalWidth: image.naturalWidth,\n      src: image.src\n    });\n  };\n\n  image.onerror = function (e) {\n    reject(e);\n  };\n};\n\nexports.loadImageAsync = loadImageAsync;\n\nvar style = (el, prop) => {\n  return typeof getComputedStyle !== 'undefined' ? getComputedStyle(el, null).getPropertyValue(prop) : el.style[prop];\n};\n\nvar overflow = el => {\n  return style(el, 'overflow') + style(el, 'overflow-y') + style(el, 'overflow-x');\n};\n\nvar scrollParent = el => {\n  if (!inBrowser) return;\n\n  if (!(el instanceof HTMLElement)) {\n    return window;\n  }\n\n  var parent = el;\n\n  while (parent) {\n    if (parent === document.body || parent === document.documentElement) {\n      break;\n    }\n\n    if (!parent.parentNode) {\n      break;\n    }\n\n    if (/(scroll|auto)/.test(overflow(parent))) {\n      return parent;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return window;\n};\n\nexports.scrollParent = scrollParent;\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction noop() {}\n\nclass ImageCache {\n  constructor({\n    max\n  }) {\n    this.options = {\n      max: max || 100\n    };\n    this._caches = [];\n  }\n\n  has(key) {\n    return this._caches.indexOf(key) > -1;\n  }\n\n  add(key) {\n    if (this.has(key)) return;\n\n    this._caches.push(key);\n\n    if (this._caches.length > this.options.max) {\n      this.free();\n    }\n  }\n\n  free() {\n    this._caches.shift();\n  }\n\n}\n\nexports.ImageCache = ImageCache;","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _util = require(\"./util\");\n\nclass ReactiveListener {\n  constructor({\n    el,\n    src,\n    error,\n    loading,\n    bindType,\n    $parent,\n    options,\n    cors,\n    elRenderer,\n    imageCache\n  }) {\n    this.el = el;\n    this.src = src;\n    this.error = error;\n    this.loading = loading;\n    this.bindType = bindType;\n    this.attempt = 0;\n    this.cors = cors;\n    this.naturalHeight = 0;\n    this.naturalWidth = 0;\n    this.options = options;\n    this.rect = null;\n    this.$parent = $parent;\n    this.elRenderer = elRenderer;\n    this._imageCache = imageCache;\n    this.performanceData = {\n      init: Date.now(),\n      loadStart: 0,\n      loadEnd: 0\n    };\n    this.filter();\n    this.initState();\n    this.render('loading', false);\n  }\n  /*\n   * init listener state\n   * @return\n   */\n\n\n  initState() {\n    if ('dataset' in this.el) {\n      this.el.dataset.src = this.src;\n    } else {\n      this.el.setAttribute('data-src', this.src);\n    }\n\n    this.state = {\n      loading: false,\n      error: false,\n      loaded: false,\n      rendered: false\n    };\n  }\n  /*\n   * record performance\n   * @return\n   */\n\n\n  record(event) {\n    this.performanceData[event] = Date.now();\n  }\n  /*\n   * update image listener data\n   * @param  {String} image uri\n   * @param  {String} loading image uri\n   * @param  {String} error image uri\n   * @return\n   */\n\n\n  update({\n    src,\n    loading,\n    error\n  }) {\n    var oldSrc = this.src;\n    this.src = src;\n    this.loading = loading;\n    this.error = error;\n    this.filter();\n\n    if (oldSrc !== this.src) {\n      this.attempt = 0;\n      this.initState();\n    }\n  }\n  /*\n   * get el node rect\n   * @return\n   */\n\n\n  getRect() {\n    this.rect = this.el.getBoundingClientRect();\n  }\n  /*\n   *  check el is in view\n   * @return {Boolean} el is in view\n   */\n\n\n  checkInView() {\n    this.getRect();\n    return this.rect.top < window.innerHeight * this.options.preLoad && this.rect.bottom > this.options.preLoadTop && this.rect.left < window.innerWidth * this.options.preLoad && this.rect.right > 0;\n  }\n  /*\n   * listener filter\n   */\n\n\n  filter() {\n    Object.keys(this.options.filter).forEach(key => {\n      this.options.filter[key](this, this.options);\n    });\n  }\n  /*\n   * render loading first\n   * @params cb:Function\n   * @return\n   */\n\n\n  renderLoading(cb) {\n    this.state.loading = true;\n    (0, _util.loadImageAsync)({\n      src: this.loading,\n      cors: this.cors\n    }, () => {\n      this.render('loading', false);\n      this.state.loading = false;\n      cb();\n    }, () => {\n      // handler `loading image` load failed\n      cb();\n      this.state.loading = false;\n      if (!this.options.silent) console.warn(\"VueLazyload log: load failed with loading image(\" + this.loading + \")\");\n    });\n  }\n  /*\n   * try load image and  render it\n   * @return\n   */\n\n\n  load(onFinish = _util.noop) {\n    if (this.attempt > this.options.attempt - 1 && this.state.error) {\n      if (!this.options.silent) console.log(\"VueLazyload log: \" + this.src + \" tried too more than \" + this.options.attempt + \" times\");\n      onFinish();\n      return;\n    }\n\n    if (this.state.rendered && this.state.loaded) return;\n\n    if (this._imageCache.has(this.src)) {\n      this.state.loaded = true;\n      this.render('loaded', true);\n      this.state.rendered = true;\n      return onFinish();\n    }\n\n    this.renderLoading(() => {\n      var _this$options$adapter, _this$options$adapter2;\n\n      this.attempt++;\n      (_this$options$adapter = (_this$options$adapter2 = this.options.adapter).beforeLoad) == null ? void 0 : _this$options$adapter.call(_this$options$adapter2, this, this.options);\n      this.record('loadStart');\n      (0, _util.loadImageAsync)({\n        src: this.src,\n        cors: this.cors\n      }, data => {\n        this.naturalHeight = data.naturalHeight;\n        this.naturalWidth = data.naturalWidth;\n        this.state.loaded = true;\n        this.state.error = false;\n        this.record('loadEnd');\n        this.render('loaded', false);\n        this.state.rendered = true;\n\n        this._imageCache.add(this.src);\n\n        onFinish();\n      }, err => {\n        !this.options.silent && console.error(err);\n        this.state.error = true;\n        this.state.loaded = false;\n        this.render('error', false);\n      });\n    });\n  }\n  /*\n   * render image\n   * @param  {String} state to render // ['loading', 'src', 'error']\n   * @param  {String} is form cache\n   * @return\n   */\n\n\n  render(state, cache) {\n    this.elRenderer(this, state, cache);\n  }\n  /*\n   * output performance data\n   * @return {Object} performance data\n   */\n\n\n  performance() {\n    var state = 'loading';\n    var time = 0;\n\n    if (this.state.loaded) {\n      state = 'loaded';\n      time = (this.performanceData.loadEnd - this.performanceData.loadStart) / 1000;\n    }\n\n    if (this.state.error) state = 'error';\n    return {\n      src: this.src,\n      state,\n      time\n    };\n  }\n  /*\n   * $destroy\n   * @return\n   */\n\n\n  $destroy() {\n    this.el = null;\n    this.src = null;\n    this.error = null;\n    this.loading = null;\n    this.bindType = null;\n    this.attempt = 0;\n  }\n\n}\n\nexports.default = ReactiveListener;","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _vue = require(\"vue\");\n\nvar _util = require(\"./util\");\n\nvar _default = lazy => {\n  return {\n    props: {\n      tag: {\n        type: String,\n        default: 'div'\n      }\n    },\n    emits: ['show'],\n\n    render() {\n      return (0, _vue.h)(this.tag, this.show && this.$slots.default ? this.$slots.default() : null);\n    },\n\n    data() {\n      return {\n        el: null,\n        state: {\n          loaded: false\n        },\n        rect: {},\n        show: false\n      };\n    },\n\n    mounted() {\n      this.el = this.$el;\n      lazy.addLazyBox(this);\n      lazy.lazyLoadHandler();\n    },\n\n    beforeUnmount() {\n      lazy.removeComponent(this);\n    },\n\n    methods: {\n      getRect() {\n        this.rect = this.$el.getBoundingClientRect();\n      },\n\n      checkInView() {\n        this.getRect();\n        return _util.inBrowser && this.rect.top < window.innerHeight * lazy.options.preLoad && this.rect.bottom > 0 && this.rect.left < window.innerWidth * lazy.options.preLoad && this.rect.right > 0;\n      },\n\n      load() {\n        this.show = true;\n        this.state.loaded = true;\n        this.$emit('show', this);\n      },\n\n      destroy() {\n        return this.$destroy;\n      }\n\n    }\n  };\n};\n\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _util = require(\"./util\");\n\n/* eslint-disable max-classes-per-file */\nvar defaultOptions = {\n  selector: 'img'\n};\n\nclass LazyContainer {\n  constructor({\n    el,\n    binding,\n    vnode,\n    lazy\n  }) {\n    this.el = null;\n    this.vnode = vnode;\n    this.binding = binding;\n    this.options = {};\n    this.lazy = lazy;\n    this._queue = [];\n    this.update({\n      el,\n      binding\n    });\n  }\n\n  update({\n    el,\n    binding\n  }) {\n    this.el = el;\n    this.options = Object.assign({}, defaultOptions, binding.value);\n    var imgs = this.getImgs();\n    imgs.forEach(el => {\n      this.lazy.add(el, Object.assign({}, this.binding, {\n        value: {\n          src: 'dataset' in el ? el.dataset.src : el.getAttribute('data-src'),\n          error: ('dataset' in el ? el.dataset.error : el.getAttribute('data-error')) || this.options.error,\n          loading: ('dataset' in el ? el.dataset.loading : el.getAttribute('data-loading')) || this.options.loading\n        }\n      }), this.vnode);\n    });\n  }\n\n  getImgs() {\n    return Array.from(this.el.querySelectorAll(this.options.selector));\n  }\n\n  clear() {\n    var imgs = this.getImgs();\n    imgs.forEach(el => this.lazy.remove(el));\n    this.vnode = null;\n    this.binding = null;\n    this.lazy = null;\n  }\n\n}\n\nclass LazyContainerManager {\n  constructor({\n    lazy\n  }) {\n    this.lazy = lazy;\n    this._queue = [];\n  }\n\n  bind(el, binding, vnode) {\n    var container = new LazyContainer({\n      el,\n      binding,\n      vnode,\n      lazy: this.lazy\n    });\n\n    this._queue.push(container);\n  }\n\n  update(el, binding, vnode) {\n    var container = (0, _util.find)(this._queue, item => item.el === el);\n    if (!container) return;\n    container.update({\n      el,\n      binding,\n      vnode\n    });\n  }\n\n  unbind(el) {\n    var container = (0, _util.find)(this._queue, item => item.el === el);\n    if (!container) return;\n    container.clear();\n    (0, _util.remove)(this._queue, container);\n  }\n\n}\n\nexports.default = LazyContainerManager;","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _util = require(\"./util\");\n\nvar _default = lazyManager => {\n  return {\n    props: {\n      src: [String, Object],\n      tag: {\n        type: String,\n        default: 'img'\n      }\n    },\n\n    render(h) {\n      return h(this.tag, {\n        attrs: {\n          src: this.renderSrc\n        }\n      }, this.$slots.default);\n    },\n\n    data() {\n      return {\n        el: null,\n        options: {\n          src: '',\n          error: '',\n          loading: '',\n          attempt: lazyManager.options.attempt\n        },\n        state: {\n          loaded: false,\n          error: false,\n          attempt: 0\n        },\n        rect: {},\n        renderSrc: ''\n      };\n    },\n\n    watch: {\n      src() {\n        this.init();\n        lazyManager.addLazyBox(this);\n        lazyManager.lazyLoadHandler();\n      }\n\n    },\n\n    created() {\n      this.init();\n      this.renderSrc = this.options.loading;\n    },\n\n    mounted() {\n      this.el = this.$el;\n      lazyManager.addLazyBox(this);\n      lazyManager.lazyLoadHandler();\n    },\n\n    beforeUnmount() {\n      lazyManager.removeComponent(this);\n    },\n\n    methods: {\n      init() {\n        var {\n          src,\n          loading,\n          error\n        } = lazyManager._valueFormatter(this.src);\n\n        this.state.loaded = false;\n        this.options.src = src;\n        this.options.error = error;\n        this.options.loading = loading;\n        this.renderSrc = this.options.loading;\n      },\n\n      getRect() {\n        this.rect = this.$el.getBoundingClientRect();\n      },\n\n      checkInView() {\n        this.getRect();\n        return _util.inBrowser && this.rect.top < window.innerHeight * lazyManager.options.preLoad && this.rect.bottom > 0 && this.rect.left < window.innerWidth * lazyManager.options.preLoad && this.rect.right > 0;\n      },\n\n      load(onFinish = _util.noop) {\n        if (this.state.attempt > this.options.attempt - 1 && this.state.error) {\n          if (!lazyManager.options.silent) console.log(\"VueLazyload log: \" + this.options.src + \" tried too more than \" + this.options.attempt + \" times\");\n          onFinish();\n          return;\n        }\n\n        var {\n          src\n        } = this.options;\n        (0, _util.loadImageAsync)({\n          src\n        }, ({\n          src\n        }) => {\n          this.renderSrc = src;\n          this.state.loaded = true;\n        }, () => {\n          this.state.attempt++;\n          this.renderSrc = this.options.error;\n          this.state.error = true;\n        });\n      }\n\n    }\n  };\n};\n\nexports.default = _default;"]}